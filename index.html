    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Global Composite Lighting</title>
        <style>
            body {
                background-color: #101020;
                margin: 0;
                padding: 0;
                width: 100vw;
                height: 100vh;
                display: flex;
                justify-content: center;
                align-items: center;
            }
        </style>
    </head>

    <body>
        <script>
            const canvasElement = document.createElement("canvas");
            canvasElement.width = 900;
            canvasElement.height = 900;
            document.body.appendChild(canvasElement);

            class Light {
                static canvas = new OffscreenCanvas(canvasElement.width, canvasElement.height);
                static ctx = this.canvas.getContext("2d", { desynchronized: true, willReadFrequently: false });
                static index = 0;
                static instances = new Map();
                constructor(x, y, radius, color) {
                    this.index = Light.index++;
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.color = color;
                    Light.instances.set(this.index, this);
                }

                destroy() {
                    Light.instances.delete(this.index);
                }

                static draw(ctx) {
                    this.ctx.globalCompositeOperation = "source-over";
                    this.ctx.fillStyle = "#000000";
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.globalCompositeOperation = "lighter";
                    for (const light of this.instances.values()) {
                        const gradient = this.ctx.createRadialGradient(light.x, light.y, 0, light.x, light.y, light.radius);
                        gradient.addColorStop(0, light.color);
                        gradient.addColorStop(1, "#00000000");
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(light.x, light.y, light.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    ctx.globalCompositeOperation = "multiply";
                    ctx.drawImage(this.canvas, 0, 0);
                    ctx.globalCompositeOperation = "source-over";
                }
            }

            class Entity {
                static index = 0;
                static instances = new Map();
                constructor(x, y, radius, color) {
                    this.index = Entity.index++;
                    this.x = x;
                    this.y = y;
                    this.velocityX = 0;
                    this.velocityY = 0;
                    this.friction = 1;
                    this.radius = radius;
                    this.color = color;
                    this.light = null;
                    Entity.instances.set(this.index, this);
                }

                destroy() {
                    Entity.instances.delete(this.index);
                    if (this.light !== null) {
                        this.light.destroy();
                    }
                }

                update(deltaTime) {
                    this.x += this.velocityX * deltaTime;
                    this.y += this.velocityY * deltaTime;
                    this.velocityX *= this.friction;
                    this.velocityY *= this.friction;
                    
                    if (this.x < this.radius) {
                        this.x = this.radius;
                        this.velocityX = -this.velocityX;
                    } else if (this.x > canvasElement.width - this.radius) {
                        this.x = canvasElement.width - this.radius;
                        this.velocityX = -this.velocityX;
                    }
                    if (this.y < this.radius) {
                        this.y = this.radius;
                        this.velocityY = -this.velocityY;
                    } else if (this.y > canvasElement.height - this.radius) {
                        this.y = canvasElement.height - this.radius;
                        this.velocityY = -this.velocityY;
                    }

                    if (this.light !== null) {
                        this.light.x = this.x;
                        this.light.y = this.y;
                    }
                }

                static draw(ctx, deltaTime) {
                    for (const entity of this.instances.values()) {
                        entity.update(deltaTime);

                        ctx.fillStyle = entity.color;
                        ctx.beginPath();
                        ctx.arc(entity.x, entity.y, entity.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            for (let i = 0; i < 10; i++) {
                const entity = new Entity(canvasElement.width * Math.random(), canvasElement.height * Math.random(), 10, `#303030`);
                const angle = Math.random() * Math.PI * 2;
                entity.velocityX = Math.cos(angle) * 100;
                entity.velocityY = Math.sin(angle) * 100;
            }

            for (let i = 0; i < 4; i++) {
                const entity = new Entity(canvasElement.width * Math.random(), canvasElement.height * Math.random(), 15, `#FF0000`);
                const angle = Math.random() * Math.PI * 2;
                entity.velocityX = Math.cos(angle) * 100;
                entity.velocityY = Math.sin(angle) * 100;
                entity.light = new Light(entity.x, entity.y, 100, `#FF0000`);
            }

            const player = new Entity(canvasElement.width / 2, canvasElement.height / 2, 20, "#FFFFFF");
            player.friction = 0.95;
            player.light = new Light(player.x, player.y, 200, `#0000FF`);

            let commands = 0;
            const COMMAND_UP = 1 << 0;
            const COMMAND_DOWN = 1 << 1;
            const COMMAND_LEFT = 1 << 2;
            const COMMAND_RIGHT = 1 << 3;
            window.addEventListener("keydown", (e) => {
                switch (e.key) {
                    case "ArrowUp":
                        commands |= COMMAND_UP;
                        break;
                    case "ArrowDown":
                        commands |= COMMAND_DOWN;
                        break;
                    case "ArrowLeft":
                        commands |= COMMAND_LEFT;
                        break;
                    case "ArrowRight":
                        commands |= COMMAND_RIGHT;
                        break;
                }
            });
            window.addEventListener("keyup", (e) => {
                switch (e.key) {
                    case "ArrowUp":
                        commands &= ~COMMAND_UP;
                        break;
                    case "ArrowDown":
                        commands &= ~COMMAND_DOWN;
                        break;
                    case "ArrowLeft":
                        commands &= ~COMMAND_LEFT;
                        break;
                    case "ArrowRight":
                        commands &= ~COMMAND_RIGHT;
                        break;
                }
            });

            const ctx = canvasElement.getContext("2d", { alpha: false, desynchronized: true, willReadFrequently: false });
            ctx.imageSmoothingEnabled = true;

            let lastTimestamp = performance.now();

            function drawBackground() {
                ctx.fillStyle = "#505050";
                ctx.fillRect(0, 0, canvasElement.width, canvasElement.height);

                ctx.strokeStyle = "#202020";
                ctx.lineWidth = 1;
                for (let x = 0; x <= canvasElement.width; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvasElement.height);
                    ctx.stroke();
                }
                for (let y = 0; y <= canvasElement.height; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvasElement.width, y);
                    ctx.stroke();
                }
            }

            function drawAnimationFrame(timestamp) {
                const deltaTime = (timestamp - lastTimestamp) / 1000;
                lastTimestamp = timestamp;

                player.velocityX += commands & COMMAND_RIGHT ? 25 : commands & COMMAND_LEFT ? -25 : 0;
                player.velocityY += commands & COMMAND_DOWN ? 25 : commands & COMMAND_UP ? -25 : 0;

                ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                drawBackground();
            
                Entity.draw(ctx, deltaTime);
                
                Light.draw(ctx);

                requestAnimationFrame(drawAnimationFrame);
            }

            requestAnimationFrame(drawAnimationFrame);
        </script>
    </body>

    </html>